AutoDSL Affordance Tech Doc
Pre-fabricated functions
Overview
1. Motivation: The key motivation of pre-fabricated functions is to encapsulate low-level, heterogeneous, empirical unit control instructions into high-level, unified, standardized natural instructions, which are more compatible with the reasoning process of LLMs, mitigating their drawback on exploiting fine-grained domain-specific knowledge. In short, we create domain-specific representations that "manage" the low-level skills and functions for high-level planning.
2. Intuition: LLMs excel at generating coarse-grained high-level natural language-based plans. However, mastering heterogeneous control tasks, such as StarCraft, requires fine-grained low-level instructions assigned to all execution units. This significant gap between the plan space and the execution space hinders the fully elicitation of LLMs' potential to serve as the centralized commander over the large potential utilization strategies of heterogeneous execution units to yield the "1+1>2" effect.
3. Objective: Pre-fabricated functions as program interfaces. The unique identifiers of these interfaces are common actions occurred in the high-level plans generated by the LLMs. Under these unique identifiers, i.e., behind the interface, there are encapsulated low-level instructions according to the configuration documents of the execution units. Furthermore, these encapsulated instructions form combinatorial skills of heterogeneous execution units that works more effectively than working isolated on their own, i.e., the effect of "1+1>2". 

Prior structure
1. An execution unit indicates a <class>, following the Object-Oriented Programming paradigm. Noted as <class object A>.
2. The attributes of the execution unit indicate the <properties> of the <class>. ("what is the execution unit?") Noted as <class object A>.<property I>.
3. The plausible operations that can be executed by the execution unit indicate the <methods> of the <class>. ("what can the execution unit do?") Noted as <class object A>.<method X>.
4. A <method> indicates a procedure of the operation conducted by the <method>. A procedure can be recursively decomposed into a series of atomic subprocedures, each defined under the precondition-postcondition paradigm. Noted as <class object A>.<method X>::=<subproc 0><subproc 1>...<subproc N>; <subproc 0>::=<precond subproc 0><execution subproc 0><postcon subproc 0>. Notably, the preconditions and postconditions may be reflected on objects other than the object defining the method.
5. The prototype execution unit of a unit family indicates a father <class>. The units in the family that are developed upon the prototype unit indicate the <classes> as class inheritance of the father <class>. Noted as <class object A'>:<class object A>.
6. The coordination between heterogenous execution units indicates the linkage between programs instantiated across different class objects. Noted as <linkage>{<program 1>|<program 2>}.
7. The linkage between programs indicates the plausible interactions between the programs, and associations that are more metaphysical. Specifically:
  1. If <class object A>.<method X> can directly apply on <class object B>.<property I>, then there is a direct <interaction> linkage between the programs indicating <class object A>.<method X> and <class object B>.<property I>. Noted as <interaction>{<class object A>.<method X>|<class object B>.<property I>}.
  2. If <class object A>.<method X> and <class object B>.<method Y> both possess <interaction> linkage with <class object C>.<property I>, then there is a latent <combination> linkage between these programs. Noted as <combination>{<class object A>.<method X>|<class object B>.<method Y>}.
  3. If <class object A>.<property I> and <class object B>.<property J> both possess <interaction> linkage with <class object C>.<method X>, then there is a latent <association> linkage between these programs. Noted as <association>{<class object A>.<property I>|<class object B>.<property J>}. 
  4. If the execution of <class object A>.<method X> directly involves the execution of <class object B>.<method Y>, then there is a latent <invocation> linkage between these programs. Noted as <invocation>{<class object A>.<method X>|<class object B>.<method Y>}.
  5. If <class object A>.<method X> cannot be directly applied to <class object B>.<property I> due to the unsatisfied precondition for execution, i.e., <class object A>.<method X>.<precond subproc 0>, and <class object C>.<method Y> resolves this condition with its postcondition, namely, <class object B>.<method Y>.<postcond subproc N> entails <class object A>.<method X>.<precond subproc 0>, then there is a latent <dependency> linkage between these programs. Noted as <dependency>{<class object A>.<method X>|<class object C>.<method Y>}.
8. The pre-fabricated functions are encapsulated according to the five types of linkages (i.e., <interaction>, <combination>, <association>, <invocation>, <dependency>) detected among the programs.

Abstract Syntax Tree of the prior structure
// Core elements
<Program> ::= (<ClassDef> | <Linkage>)*

<ClassDef> ::= "<class object" ClassName ">" [":" "<class object" ParentClassName ">"] "{" (<Property> | <Method>)* "}"

<Property> ::= "<property" PropertyName ">"

<Method> ::= "<method" MethodName ">::=" <Procedure>

<Procedure> ::= <SubProcedure> (";" <SubProcedure>)*

<SubProcedure> ::= "<subproc" SubProcID ">::=" <Precondition> <Execution> <Postcondition>

<Precondition> ::= "<precond subproc" SubProcID ">" ConditionExpression

<Postcondition> ::= "<postcond subproc" SubProcID ">" ConditionExpression

<Execution> ::= ExecutionStatement


// Reference types
<ClassRef> ::= "<class object" ClassName ">"
<PropertyRef> ::= <ClassRef> "." "<property" PropertyName ">"
<MethodRef> ::= <ClassRef> "." "<method" MethodName ">"
<SubProcRef> ::= <MethodRef> "::" "<subproc" SubProcID ">"


// Linkage types
<Linkage> ::= <InteractionLinkage> 
            | <CombinationLinkage> 
            | <AssociationLinkage> 
            | <InvocationLinkage> 
            | <DependencyLinkage>

<InteractionLinkage> ::= "<interaction>{" <MethodRef> "|" <PropertyRef> "}"

<CombinationLinkage> ::= "<combination>{" <MethodRef> "|" <MethodRef> "}"

<AssociationLinkage> ::= "<association>{" <PropertyRef> "|" <PropertyRef> "}"

<InvocationLinkage> ::= "<invocation>{" <MethodRef> "|" <MethodRef> "}"

<DependencyLinkage> ::= "<dependency>{" <MethodRef> "|" <MethodRef> "}"


// Condition and execution primitives
<ConditionExpression> ::= <AtomicCondition> 
                       | <ConditionExpression> "∧" <ConditionExpression>
                       | <ConditionExpression> "∨" <ConditionExpression>
                       | "¬" <ConditionExpression>
                       | "(" <ConditionExpression> ")"

<AtomicCondition> ::= <PropertyRef> <ComparisonOp> Value
                    | <SubProcRef> "." ("<precond>" | "<postcond>")

<ComparisonOp> ::= "=" | "≠" | "<" | ">" | "≤" | "≥" | "∈" | "⊆"

<ExecutionStatement> ::= // atomic operations

Combinatorial skill encapsulation algorithm
1. Loop for each execution unit:
  1. Access the exact documentation of the execution unit;
  2. Identify information related to the execution unit and the unique class name (may exploit LLMs to handle the unformatted documentation for this step and the following steps);
  3. Identify class inheritance relationship, i.e., whether it is a prototype-level father class or a developed child class;
  4. Abstract the syntax structure of the class object, i.e., the fields of properties and methods ("what dimensions to describe the properties and methods of the class?");
  5. Operationalize the methods with execution-level instructions and parameters for the implementation of real-time interaction with the environment;
  6. Ground the semantics of the class object, i.e., determine the values to the fields of properties and methods ("what are the exact properties and methods of the class?");
2. Once all of the current execution units are abstracted into class objects, construct them into a multi-layer graph named the program linkage graph:
  1. Define the basic syntax of the graph nodes: a node maps to a class, with its properties and methods map to the attributes of the node;
  2. Define the basic syntax of the graph edges: a program linkage maps to an edge, it can be either undirected (for <interaction>, <combination>, and <association>) or directed (for <invocation> and <dependency>);
  3. Conduct several rounds of graph traversal: creates edges among nodes, focus on only one type of linkage during each round of traversal, following some potential dependencies between linkages, e.g., edges indicating <combination>, <association>, and <dependency> linkages can only be identified after all edges indicating <interaction> linkage have been identified;
3. Once the program linkage graph is constructed:
  1. Encapsulate all programs with first-order <interaction> linkage, identify the function as "setting <class object A>.<property I> as the target object for this action";
  2. Detect the connected components and maximal cliques of <combination> linkages, identify the function as "setting <class object A>.<property I> as the target object for this action"---these are encapsulations of concurrent operations;
  3. Detect the connected components and maximal cliques of <association> linkages, identify the function as "being influenced by <class object A>.<method X>"---these are encapsulations of parallel operations;
  4. Detect the connected components and maximal cliques of <invocation> linkages, identify the function as "changing the environment from <class object Source>.<method X>.<precond subproc 0> to <class object Destination>.<method Y>.<postcond subproc N>"---these are encapsulations of sequential operations;
  5. Detect the conneted component and maximal cliques of <dependency> linkages, identify the function as "metting the prerequisite for <class object Destination>.<method X>"---these are encapsulations of sequential operations. 
4. Once the program library of pre-fabricated functions is constructed:
  1. Unify the identification scheme of the functions, to make sure each of them is assigned with a unique identifier;
  2. Aggregate the parameters within the functions which should serve as function arguments---when the function is called by users, such as LLMs, the arguments should provide them with interfaces to customize the function---and then abstract the parameters into arguments with pre-defined plausible domains;
  3. Check the consistency between the abstracted function arguments and the execution-level instructions to ensure correct execution;
  4. (Optional, to be decided according to the exact implementation status) Conduct reward shaping with the objective of the function for complicated combinatorial skill training through reinforcement learning. 
5. Deploy the validated program library to the LLM-based planner.